package filemgr

import (
	"errors"
	"fmt"
	"image"
	"image/jpeg"
	"io"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"

	"github.com/disintegration/imaging"
	"github.com/google/uuid"
)

// SaveFile writes the contents of multipart.File to disk under destDir.
// It returns the generated filename (without path) or an error.
func SaveFile(file multipart.File, header *multipart.FileHeader, destDir string) (string, error) {
	defer file.Close()

	if err := os.MkdirAll(destDir, 0o755); err != nil {
		return "", fmt.Errorf("mkdir %s: %w", destDir, err)
	}

	ext := filepath.Ext(header.Filename)
	name := uuid.New().String() + ext
	fullPath := filepath.Join(destDir, name)

	out, err := os.Create(fullPath)
	if err != nil {
		return "", fmt.Errorf("create %s: %w", fullPath, err)
	}
	defer out.Close()

	if _, err := io.Copy(out, file); err != nil {
		return "", fmt.Errorf("write %s: %w", fullPath, err)
	}

	return name, nil
}

// SaveFormFile fetches formKey from r, saves it into destDir, and
// returns the filename. If required is true and the field is missing, returns an error.
func SaveFormFile(r *http.Request, formKey, destDir string, required bool) (string, error) {
	file, header, err := r.FormFile(formKey)
	if err != nil {
		if !required && err == http.ErrMissingFile {
			return "", nil
		}
		return "", fmt.Errorf("%s: %w", formKey, err)
	}
	return SaveFile(file, header, destDir)
}

// SaveFormFiles fetches all files under formKey, saves them to destDir,
// and returns a slice of filenames. If none are found and required is true, error.
func SaveFormFiles(r *http.Request, formKey, destDir string, required bool) ([]string, error) {
	files := r.MultipartForm.File[formKey]
	if len(files) == 0 {
		if required {
			return nil, errors.New(formKey + " is required")
		}
		return nil, nil
	}

	var names []string
	for _, hdr := range files {
		file, err := hdr.Open()
		if err != nil {
			return nil, fmt.Errorf("open %s: %w", hdr.Filename, err)
		}
		name, err := SaveFile(file, hdr, destDir)
		if err != nil {
			return nil, err
		}
		names = append(names, name)
	}
	return names, nil
}

// SaveImageWithThumb saves an image form field, writes both the original and
// a thumbnail of width thumbWidth (keeping aspect) into destDir/thumbs.
// Returns (originalFilename, thumbFilename, error).
func SaveImageWithThumb(r *http.Request, formKey, destDir string, thumbWidth int, required bool) (string, string, error) {
	file, header, err := r.FormFile(formKey)
	if err != nil {
		if !required && err == http.ErrMissingFile {
			return "", "", nil
		}
		return "", "", fmt.Errorf("%s: %w", formKey, err)
	}
	defer file.Close()

	// Decode image
	img, _, err := image.Decode(file)
	if err != nil {
		return "", "", fmt.Errorf("decode %s: %w", header.Filename, err)
	}

	// Reset reader to re-read bytes
	if seeker, ok := file.(io.Seeker); ok {
		seeker.Seek(0, io.SeekStart)
	} else {
		return "", "", errors.New("file is not seekable")
	}

	// Save original
	origName, err := SaveFile(file, header, destDir)
	if err != nil {
		return "", "", err
	}

	// Create thumb dir
	thumbDir := filepath.Join(destDir, "thumbs")
	if err := os.MkdirAll(thumbDir, 0o755); err != nil {
		return origName, "", fmt.Errorf("mkdir %s: %w", thumbDir, err)
	}

	thumbImg := imaging.Resize(img, thumbWidth, 0, imaging.Lanczos)
	thumbName := uuid.New().String() + ".jpg"
	thumbPath := filepath.Join(thumbDir, thumbName)

	out, err := os.Create(thumbPath)
	if err != nil {
		return origName, "", fmt.Errorf("create thumb %s: %w", thumbPath, err)
	}
	defer out.Close()

	if err := jpeg.Encode(out, thumbImg, &jpeg.Options{Quality: 85}); err != nil {
		return origName, "", fmt.Errorf("encode thumb: %w", err)
	}

	return origName, thumbName, nil
}
