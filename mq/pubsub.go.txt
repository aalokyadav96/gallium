package mq

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/nats-io/nats.go"
	"github.com/redis/go-redis/v9"
)

type PubSub interface {
	Publish(topic string, message []byte) error
	Subscribe(topic string, handler func([]byte) error) error
	Close() error
}

// ======================
// Redis Streams
// ======================

type RedisPubSub struct {
	client *redis.Client
}

func NewRedisPubSub(addr string, password string, db int) *RedisPubSub {
	return &RedisPubSub{
		client: redis.NewClient(&redis.Options{
			Addr:     addr,
			Password: password,
			DB:       db,
		}),
	}
}

func (r *RedisPubSub) Publish(topic string, message []byte) error {
	return r.client.XAdd(context.TODO(), &redis.XAddArgs{
		Stream: topic,
		Values: map[string]interface{}{"data": message},
	}).Err()
}

func (r *RedisPubSub) Subscribe(topic string, handler func([]byte) error) error {
	ctx := context.TODO()
	lastID := "$" // read new messages only
	for {
		streams, err := r.client.XRead(ctx, &redis.XReadArgs{
			Streams: []string{topic, lastID},
			Block:   0, // block until new message
		}).Result()
		if err != nil {
			return err
		}
		for _, stream := range streams {
			for _, msg := range stream.Messages {
				dataStr, ok := msg.Values["data"].(string)
				if !ok {
					continue
				}
				if err := handler([]byte(dataStr)); err != nil {
					// Optional: log or push to DLQ
				}
				lastID = msg.ID
			}
		}
	}
}

func (r *RedisPubSub) Close() error {
	return r.client.Close()
}

// ======================
// NATS
// ======================

type NatsPubSub struct {
	nc *nats.Conn
}

func NewNatsPubSub(url string) (*NatsPubSub, error) {
	nc, err := nats.Connect(url)
	if err != nil {
		return nil, err
	}
	return &NatsPubSub{nc: nc}, nil
}

func (n *NatsPubSub) Publish(topic string, message []byte) error {
	return n.nc.Publish(topic, message)
}

func (n *NatsPubSub) Subscribe(topic string, handler func([]byte) error) error {
	_, err := n.nc.Subscribe(topic, func(m *nats.Msg) {
		_ = handler(m.Data)
	})
	if err != nil {
		return err
	}
	select {} // block forever
}

func (n *NatsPubSub) Close() error {
	n.nc.Close()
	return nil
}

// ======================
// Factory
// ======================

type PubSubType string

const (
	PubSubRedis PubSubType = "redis"
	PubSubNats  PubSubType = "nats"
)

type PubSubConfig struct {
	Type     PubSubType
	Addr     string // Redis address or NATS URL
	Password string // Redis password
	DB       int    // Redis DB number
}

func NewPubSub(cfg PubSubConfig) (PubSub, error) {
	switch cfg.Type {
	case PubSubRedis:
		return NewRedisPubSub(cfg.Addr, cfg.Password, cfg.DB), nil
	case PubSubNats:
		ps, err := NewNatsPubSub(cfg.Addr)
		if err != nil {
			return nil, err
		}
		return ps, nil
	default:
		return nil, errors.New("unsupported pubsub type")
	}
}

// ======================
// Helper for publishing events
// ======================

func PublishEvent(ps PubSub, topic string, v interface{}) error {
	data, err := json.Marshal(v)
	if err != nil {
		return fmt.Errorf("marshal event: %w", err)
	}
	return ps.Publish(topic, data)
}

// Example event type
type ImageSavedEvent struct {
	LocalPath string `json:"local_path"`
	Entity    string `json:"entity"`
	FileName  string `json:"file_name"`
	PicType   string `json:"pic_type"`
	CreatedAt int64  `json:"created_at"`
}

func NewImageSavedEvent(localPath, entity, fileName, picType string) ImageSavedEvent {
	return ImageSavedEvent{
		LocalPath: localPath,
		Entity:    entity,
		FileName:  fileName,
		PicType:   picType,
		CreatedAt: time.Now().Unix(),
	}
}
